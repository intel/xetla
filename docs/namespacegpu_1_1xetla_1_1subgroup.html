<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XeTLA: gpu::xetla::subgroup Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">XeTLA<span id="projectnumber">&#160;v0.3.1</span>
   </div>
   <div id="projectbrief">IntelÂ® Xe Templates for Linear Algebra - API Definition Document</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacegpu_1_1xetla_1_1subgroup.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">gpu::xetla::subgroup Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegpu_1_1xetla_1_1subgroup_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1bias__add__op__t.html">bias_add_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the bias_add op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1bias__add__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1bias__add__op__t_3_01dtype__bias___00_01gpu__arch_1_1Xe_01_4.html">bias_add_op_t&lt; dtype_bias_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the bias_add op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1bias__add__op__t_3_01dtype__bias___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1chained__tile__op__arg__t.html">chained_tile_op_arg_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1chained__tile__op__arg__t_3_01idx_00_01curr__args__t_00_01remain__args__t_8_8_8_01_4.html">chained_tile_op_arg_t&lt; idx, curr_args_t, remain_args_t... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1chained__tile__op__t.html">chained_tile_op_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1dropout__op__t.html">dropout_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the dropout op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1dropout__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1dropout__op__t_3_01dtype__mask___00_01gpu__arch_1_1Xe_01_4.html">dropout_op_t&lt; dtype_mask_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the dropout op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1dropout__op__t_3_01dtype__mask___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1elemwise__reduce__op__t.html">elemwise_reduce_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise reduce op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1elemwise__reduce__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1elemwise__reduce__op__t_3_01reduce__kind___00_01dtype__in___00_01gpu__arch_1_1Xe_01_4.html">elemwise_reduce_op_t&lt; reduce_kind_, dtype_in_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise reduce op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1elemwise__reduce__op__t_3_01reduce__kind___00_01dtype__in___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1gelu__bwd__op__t.html">gelu_bwd_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise gelu backward op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1gelu__bwd__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1gelu__bwd__op__t_3_01dtype__in___00_01gpu__arch_1_1Xe_01_4.html">gelu_bwd_op_t&lt; dtype_in_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise gelu backward op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1gelu__bwd__op__t_3_01dtype__in___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1gelu__fwd__op__t.html">gelu_fwd_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise gelu inference forward op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1gelu__fwd__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1gelu__fwd__w__op__t.html">gelu_fwd_w_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise gelu training forward op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1gelu__fwd__w__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1gelu__fwd__w__op__t_3_01dtype__out___00_01gpu__arch_1_1Xe_01_4.html">gelu_fwd_w_op_t&lt; dtype_out_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise gelu training forward op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1gelu__fwd__w__op__t_3_01dtype__out___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1get__load__block__size__auto.html">get_load_block_size_auto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1get__load__block__size__auto_3_01dtype_00_01tile__size__x_00_043561ddbe884fdfdc5805813b0293052.html">get_load_block_size_auto&lt; dtype, tile_size_x, tile_size_y, gpu_arch::Xe, mem_layout::row_major, reg_layout::tiled &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1get__store__block__size__auto.html">get_store_block_size_auto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1get__store__block__size__auto_3_01dtype_00_01tile__size__x_00_7188bde0744e02dc2363bd5e8a330d24.html">get_store_block_size_auto&lt; dtype, tile_size_x, tile_size_y, gpu_arch::Xe, mem_layout::row_major, reg_layout::tiled &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html">mem_payload_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to illustrate the memory information.  <a href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_1d44935cfd2d9fbcb517f77b34aee250d.html">mem_payload_t&lt; dtype_, tile_desc_, msg_type::atomic_add, mem_layout::row_major, mem_space::global, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the global memory surface for atomic store For atomic store, we need to prepare necessary information for each simd channel.  <a href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_1d44935cfd2d9fbcb517f77b34aee250d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_147e897667466bee4b1df4af591b57456.html">mem_payload_t&lt; dtype_, tile_desc_, msg_type::block_1d, mem_layout::row_major, mem_space::global, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the global memory surface for block-1d load/store For a block-1d payload message we need to set the base address and offset of surface.  <a href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_147e897667466bee4b1df4af591b57456.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_1f0a2e0555f50e1106c25d511b2ef330c.html">mem_payload_t&lt; dtype_, tile_desc_, msg_type::block_1d, mem_layout::row_major, mem_space::local, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the shared local memory surface for block-1d load/store.  <a href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_1f0a2e0555f50e1106c25d511b2ef330c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_18465855538f8a6320758be5c96a1b436.html">mem_payload_t&lt; dtype_, tile_desc_, msg_type::block_2d, mem_layout_, mem_space::global, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the global memory surface for block-2d load/store for each block in one tile, a payload message is prepared here.  <a href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_18465855538f8a6320758be5c96a1b436.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_1a7116e3500e7d436cd40eb16a8981457.html">mem_payload_t&lt; dtype_, tile_desc_, msg_type::scatter, mem_layout::row_major, mem_space::local, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the shared local memory surface for scatter load/store.  <a href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc___00_01msg__type_1a7116e3500e7d436cd40eb16a8981457.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc__t_3_01tile__size_12caaae346d41f6005357bdd14a3a96e.html">mem_payload_t&lt; dtype_, tile_desc_t&lt; tile_size_x_, tile_size_y_, block_size_x_, block_size_y_, reg_layout::vnni_tiled_col_major &gt;, msg_type::scatter, mem_layout::row_major, mem_space::local, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the shared local memory surface for scattering store.  <a href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t_3_01dtype___00_01tile__desc__t_3_01tile__size_12caaae346d41f6005357bdd14a3a96e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1msg__type__query.html">msg_type_query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1none__op__t.html">none_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is none op functor, for placeholder purpose.  <a href="structgpu_1_1xetla_1_1subgroup_1_1none__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1polynomial__op__t.html">polynomial_op_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t.html">prefetch_payload_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to illustrate the memory information to prefetch data to cache.  <a href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t_3_01dtype___00_01tile__desc___00_01mem__l07cbb4a3da2d2f362ea2b0be0bf263d1.html">prefetch_payload_t&lt; dtype_, tile_desc_, mem_layout_, mem_space::local, cooperative_num_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the memory infomation to prefetch data to cache data located in shared local memory, nothing will do.  <a href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t_3_01dtype___00_01tile__desc___00_01mem__l07cbb4a3da2d2f362ea2b0be0bf263d1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t_3_01dtype___00_01tile__desc__t_3_01tile__69cc1ab5b7f4056fabbb305077c9250b.html">prefetch_payload_t&lt; dtype_, tile_desc_t&lt; tile_size_x_, 1, block_size_x_, 1, reg_layout::tiled &gt;, mem_layout_, mem_space::global, cooperative_num_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the memory memory to prefetch data to cache data in global memory will be prefetched into 1d tile.  <a href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t_3_01dtype___00_01tile__desc__t_3_01tile__69cc1ab5b7f4056fabbb305077c9250b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t_3_01dtype___00_01tile__desc__t_3_01tile__a9e0269e15e079bfb5be4835926eb5be.html">prefetch_payload_t&lt; dtype_, tile_desc_t&lt; tile_size_x_, tile_size_y_, block_size_x_, block_size_y_, reg_layout::tiled &gt;, mem_layout_, mem_space::global, cooperative_num_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to describe the global memory surface to prefetch data to cache data in global memory will be prefetched into 2d tile.  <a href="structgpu_1_1xetla_1_1subgroup_1_1prefetch__payload__t_3_01dtype___00_01tile__desc__t_3_01tile__a9e0269e15e079bfb5be4835926eb5be.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1quant__op__t.html">quant_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the quantization op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1quant__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1quant__op__t_3_01dtype__offset__scale___00_01gpu__arch_1_1Xe_01_4.html">quant_op_t&lt; dtype_offset_scale_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the quantization op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1quant__op__t_3_01dtype__offset__scale___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1relu__op__t.html">relu_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element-wise relu op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1relu__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1rng__dropout__op__t.html">rng_dropout_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the random number generator and dropout op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1rng__dropout__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1rng__dropout__op__t_3_01dtype__mask___00_01gpu__arch_1_1Xe_01_4.html">rng_dropout_op_t&lt; dtype_mask_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the random number generator and dropout op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1rng__dropout__op__t_3_01dtype__mask___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1scalar__mul__op__t.html">scalar_mul_op_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the scalar_multiply op functor.  <a href="structgpu_1_1xetla_1_1subgroup_1_1scalar__mul__op__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1scalar__mul__op__t_3_01dtype__in___00_01gpu__arch_1_1Xe_01_4.html">scalar_mul_op_t&lt; dtype_in_, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the scalar_multiply op functor, specialized for Xe architecture.  <a href="structgpu_1_1xetla_1_1subgroup_1_1scalar__mul__op__t_3_01dtype__in___00_01gpu__arch_1_1Xe_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__desc__t.html">tile_desc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is to illustrate the tile information about a sub matrix.  <a href="structgpu_1_1xetla_1_1subgroup_1_1tile__desc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__div.html">tile_div</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__minus.html">tile_minus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__mma__t.html">tile_mma_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the xetla tile mma operation definition API.  <a href="structgpu_1_1xetla_1_1subgroup_1_1tile__mma__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__mma__t_3_01matA__t___00_01matB__t___00_01matAcc__src__t_5e326f93053a5dc419a1202cd6d31c87.html">tile_mma_t&lt; matA_t_, matB_t_, matAcc_src_t_, matAcc_dst_t_, mma_engine::fpu, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the tile mma operation functor, specialized for Xe and fpu engine.  <a href="structgpu_1_1xetla_1_1subgroup_1_1tile__mma__t_3_01matA__t___00_01matB__t___00_01matAcc__src__t_5e326f93053a5dc419a1202cd6d31c87.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__mma__t_3_01matA__t___00_01matB__t___00_01matAcc__src__t_7f67d172949e9727b2f7953429f66a95.html">tile_mma_t&lt; matA_t_, matB_t_, matAcc_src_t_, matAcc_dst_t_, mma_engine::xmx, gpu_arch::Xe &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the tile mma operation functor, specialized for Xe and matrix engine.  <a href="structgpu_1_1xetla_1_1subgroup_1_1tile__mma__t_3_01matA__t___00_01matB__t___00_01matAcc__src__t_7f67d172949e9727b2f7953429f66a95.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__op__arg__helper__t.html">tile_op_arg_helper_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a struct contains some register file.  <a href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad458951cf3988199a5217f2e6017a486"><td class="memTemplParams" colspan="2">template&lt;typename op , typename matAcc_t &gt; </td></tr>
<tr class="memitem:ad458951cf3988199a5217f2e6017a486"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#ad458951cf3988199a5217f2e6017a486">tile_broadcast_op</a> (matAcc_t &amp;matAcc, <a class="el" href="group__xetla__core__base__types.html#ga8cf5d016d24c8870706e20c376287e04">xetla_vector</a>&lt; typename matAcc_t::dtype, matAcc_t::tile_size_y &gt; data)</td></tr>
<tr class="separator:ad458951cf3988199a5217f2e6017a486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae110043dd5332ce2a7ef91d2c8ae79ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:ae110043dd5332ce2a7ef91d2c8ae79ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_2d_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#ae110043dd5332ce2a7ef91d2c8ae79ef">tile_load</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:ae110043dd5332ce2a7ef91d2c8ae79ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads data from 2D memory surface.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#ae110043dd5332ce2a7ef91d2c8ae79ef">More...</a><br /></td></tr>
<tr class="separator:ae110043dd5332ce2a7ef91d2c8ae79ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af981410d657174c1d3d7e9e0ce45a9c8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:af981410d657174c1d3d7e9e0ce45a9c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_block_1d_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#af981410d657174c1d3d7e9e0ce45a9c8">tile_load</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:af981410d657174c1d3d7e9e0ce45a9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function loads data from memory.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#af981410d657174c1d3d7e9e0ce45a9c8">More...</a><br /></td></tr>
<tr class="separator:af981410d657174c1d3d7e9e0ce45a9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e7576711f868349f625b3aa92db238"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:a12e7576711f868349f625b3aa92db238"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_scatter_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a12e7576711f868349f625b3aa92db238">tile_load</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:a12e7576711f868349f625b3aa92db238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the data load func from local shared memory to register file, which supports the memory surface is 1d or 2d scenario.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a12e7576711f868349f625b3aa92db238">More...</a><br /></td></tr>
<tr class="separator:a12e7576711f868349f625b3aa92db238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cb1cc8488ef2bed589c9719b8b5713"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:a79cb1cc8488ef2bed589c9719b8b5713"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_block_1d_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a79cb1cc8488ef2bed589c9719b8b5713">tile_load</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:a79cb1cc8488ef2bed589c9719b8b5713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the data load func from shared local memory to register file, which supports the memory surface is 1d scenario.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a79cb1cc8488ef2bed589c9719b8b5713">More...</a><br /></td></tr>
<tr class="separator:a79cb1cc8488ef2bed589c9719b8b5713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b69b15b52946f9458d1ed844d7bd8d3"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T_src &gt; </td></tr>
<tr class="memitem:a8b69b15b52946f9458d1ed844d7bd8d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_src::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_dst::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_src::tile_desc::block_size_y==T_dst::tile_desc::block_size_y) &amp;&amp;(T_src::tile_desc::block_size_x==T_dst::tile_desc::block_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==T_dst::tile_desc::tile_size_y) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a8b69b15b52946f9458d1ed844d7bd8d3">elemwise_cvt</a> (T_dst &amp;dst, T_src &amp;src)</td></tr>
<tr class="memdesc:a8b69b15b52946f9458d1ed844d7bd8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element wise data conversion, the src and dst tile should have the same layout.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a8b69b15b52946f9458d1ed844d7bd8d3">More...</a><br /></td></tr>
<tr class="separator:a8b69b15b52946f9458d1ed844d7bd8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81487253528fefbbbd9ca5b394ca2c4"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T_src &gt; </td></tr>
<tr class="memitem:ac81487253528fefbbbd9ca5b394ca2c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_src::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_dst::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_src::tile_desc::block_size_y==T_dst::tile_desc::block_size_y) &amp;&amp;(T_src::tile_desc::block_size_x==T_dst::tile_desc::block_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==T_dst::tile_desc::tile_size_y) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#ac81487253528fefbbbd9ca5b394ca2c4">elemwise_cvt</a> (T_dst &amp;dst, T_src &amp;src, float scale)</td></tr>
<tr class="memdesc:ac81487253528fefbbbd9ca5b394ca2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">element wise data conversion with scaling, the src and dst tile should have the same layout.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#ac81487253528fefbbbd9ca5b394ca2c4">More...</a><br /></td></tr>
<tr class="separator:ac81487253528fefbbbd9ca5b394ca2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc58c46491bd67b07a6e930b909a552"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> , <a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98">post_kind</a> post_op&gt; </td></tr>
<tr class="memitem:a3dc58c46491bd67b07a6e930b909a552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; post_op==<a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98abc5ce62b39aff2f661146911808eadc1">post_kind::relu</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a3dc58c46491bd67b07a6e930b909a552">elemwise_op</a> (<a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;mat_Acc)</td></tr>
<tr class="memdesc:a3dc58c46491bd67b07a6e930b909a552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element wise op for relu.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a3dc58c46491bd67b07a6e930b909a552">More...</a><br /></td></tr>
<tr class="separator:a3dc58c46491bd67b07a6e930b909a552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c2f3de3e4f22840cb553cc3a09408c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> , <a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98">post_kind</a> post_op&gt; </td></tr>
<tr class="memitem:ad1c2f3de3e4f22840cb553cc3a09408c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; post_op==<a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98ab3be9d0a0747f09c4bb18840003e3f9a">post_kind::gelu</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#ad1c2f3de3e4f22840cb553cc3a09408c">elemwise_op</a> (<a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;mat_Acc)</td></tr>
<tr class="memdesc:ad1c2f3de3e4f22840cb553cc3a09408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element wise op for gelu.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#ad1c2f3de3e4f22840cb553cc3a09408c">More...</a><br /></td></tr>
<tr class="separator:ad1c2f3de3e4f22840cb553cc3a09408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37e62fa495a0c8237930a4f39daece9"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> , <a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98">post_kind</a> post_op&gt; </td></tr>
<tr class="memitem:aa37e62fa495a0c8237930a4f39daece9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; post_op==<a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98a5c0dbba3a6ee4ac0eb26cfee75ccb8b4">post_kind::tanh</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#aa37e62fa495a0c8237930a4f39daece9">elemwise_op</a> (<a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;mat_Acc)</td></tr>
<tr class="memdesc:aa37e62fa495a0c8237930a4f39daece9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the element wise op for tanh.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#aa37e62fa495a0c8237930a4f39daece9">More...</a><br /></td></tr>
<tr class="separator:aa37e62fa495a0c8237930a4f39daece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b12c34ad3ef3de43d0b01c4e5e1134"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &gt; </td></tr>
<tr class="memitem:a81b12c34ad3ef3de43d0b01c4e5e1134"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; T::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9c072496656f07aeb105a1bc09a218b5">reg_layout::vnni_tiled</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a81b12c34ad3ef3de43d0b01c4e5e1134">vnni_reverse</a> (<a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;mat_Acc)</td></tr>
<tr class="memdesc:a81b12c34ad3ef3de43d0b01c4e5e1134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts vnni_tiled layout format to tiled layout.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a81b12c34ad3ef3de43d0b01c4e5e1134">More...</a><br /></td></tr>
<tr class="separator:a81b12c34ad3ef3de43d0b01c4e5e1134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f0095d099fd6925beaf78858106ba7"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T_src &gt; </td></tr>
<tr class="memitem:a62f0095d099fd6925beaf78858106ba7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_src::tile_desc::block_size_y==T_dst::tile_desc::block_size_y) &amp;&amp;(T_src::tile_desc::block_size_x==T_dst::tile_desc::block_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==T_dst::tile_desc::tile_size_y) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a62f0095d099fd6925beaf78858106ba7">vnni_transform</a> (T_dst &amp;dst, T_src &amp;src)</td></tr>
<tr class="memdesc:a62f0095d099fd6925beaf78858106ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes vnni layout.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a62f0095d099fd6925beaf78858106ba7">More...</a><br /></td></tr>
<tr class="separator:a62f0095d099fd6925beaf78858106ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a12cfd0a2d3621b16109bfe772558d"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T_src &gt; </td></tr>
<tr class="memitem:af6a12cfd0a2d3621b16109bfe772558d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_dst::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_src::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#af6a12cfd0a2d3621b16109bfe772558d">row_broadcast</a> (T_dst &amp;dst, T_src &amp;src)</td></tr>
<tr class="memdesc:af6a12cfd0a2d3621b16109bfe772558d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts 1d src tile to the entire 2d tile, as well as do the data conversion.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#af6a12cfd0a2d3621b16109bfe772558d">More...</a><br /></td></tr>
<tr class="separator:af6a12cfd0a2d3621b16109bfe772558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceb202d8614f8ac1526c8d6d81871af"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename payload_t &gt; </td></tr>
<tr class="memitem:aaceb202d8614f8ac1526c8d6d81871af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__prefetch__type.html">detail::check_prefetch_type</a>&lt; payload_t &gt;::is_global_2d_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#aaceb202d8614f8ac1526c8d6d81871af">tile_prefetch</a> (payload_t &amp;payload)</td></tr>
<tr class="memdesc:aaceb202d8614f8ac1526c8d6d81871af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is prefetch data func, which data located in global memory is prefetched to cache, where has higher bandwidth.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#aaceb202d8614f8ac1526c8d6d81871af">More...</a><br /></td></tr>
<tr class="separator:aaceb202d8614f8ac1526c8d6d81871af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5f23fa860546dda8f99f578d614198"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename payload_t &gt; </td></tr>
<tr class="memitem:a4a5f23fa860546dda8f99f578d614198"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__prefetch__type.html">detail::check_prefetch_type</a>&lt; payload_t &gt;::is_global_block_1d_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a4a5f23fa860546dda8f99f578d614198">tile_prefetch</a> (payload_t &amp;payload)</td></tr>
<tr class="memdesc:a4a5f23fa860546dda8f99f578d614198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is prefetch data func, which data located in global memory is prefetched to cache, where has higher bandwidth.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a4a5f23fa860546dda8f99f578d614198">More...</a><br /></td></tr>
<tr class="separator:a4a5f23fa860546dda8f99f578d614198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae231c0f2ba538dd630ff96861a796544"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename payload_t &gt; </td></tr>
<tr class="memitem:ae231c0f2ba538dd630ff96861a796544"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__prefetch__type.html">detail::check_prefetch_type</a>&lt; payload_t &gt;::is_local_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#ae231c0f2ba538dd630ff96861a796544">tile_prefetch</a> (payload_t &amp;payload)</td></tr>
<tr class="memdesc:ae231c0f2ba538dd630ff96861a796544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is prefetch data func.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#ae231c0f2ba538dd630ff96861a796544">More...</a><br /></td></tr>
<tr class="separator:ae231c0f2ba538dd630ff96861a796544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c36bfacc34c29c899bcbc53473148ac"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a7bbd70f1164d3a7251729e89fffc0609">reduce_op</a> reduce_kind, typename mat_t , typename dtype_acc , int dim&gt; </td></tr>
<tr class="memitem:a1c36bfacc34c29c899bcbc53473148ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(dim==1), <a class="el" href="group__xetla__core__base__types.html#ga8cf5d016d24c8870706e20c376287e04">xetla_vector</a>&lt; typename mat_t::dtype, mat_t::tile_desc::tile_size_y &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a1c36bfacc34c29c899bcbc53473148ac">tile_reduce</a> (mat_t &amp;src)</td></tr>
<tr class="separator:a1c36bfacc34c29c899bcbc53473148ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3737ab94d26bfe109fa71cfc8ca92c"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T_src , bool accumulate = true, typename dtype_acc  = float, uint32_t num_acc = 4&gt; </td></tr>
<tr class="memitem:abb3737ab94d26bfe109fa71cfc8ca92c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_dst::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_src::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_dst::tile_desc::tile_size_x==T_src::tile_desc::tile_size_x) &amp;&amp;(T_dst::tile_desc::tile_size_y==1)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#abb3737ab94d26bfe109fa71cfc8ca92c">tile_row_reduce</a> (T_dst &amp;dst, T_src &amp;src)</td></tr>
<tr class="memdesc:abb3737ab94d26bfe109fa71cfc8ca92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce 2d src tile to the 1d tile, and output to 1d dst.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#abb3737ab94d26bfe109fa71cfc8ca92c">More...</a><br /></td></tr>
<tr class="separator:abb3737ab94d26bfe109fa71cfc8ca92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca86d85d16cd70ce167a4819af5d29ef"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:aca86d85d16cd70ce167a4819af5d29ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_2d_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#aca86d85d16cd70ce167a4819af5d29ef">tile_store</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:aca86d85d16cd70ce167a4819af5d29ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the func storing data from register file to global memory.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#aca86d85d16cd70ce167a4819af5d29ef">More...</a><br /></td></tr>
<tr class="separator:aca86d85d16cd70ce167a4819af5d29ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343abc18e254f69fa1f67cbef11d187b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:a343abc18e254f69fa1f67cbef11d187b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_block_1d_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a343abc18e254f69fa1f67cbef11d187b">tile_store</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:a343abc18e254f69fa1f67cbef11d187b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the func storing data from register file to global memory.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a343abc18e254f69fa1f67cbef11d187b">More...</a><br /></td></tr>
<tr class="separator:a343abc18e254f69fa1f67cbef11d187b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fdbed0d815037de1dc7e1e9e80c485"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::uncached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:ae2fdbed0d815037de1dc7e1e9e80c485"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_atomic_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#ae2fdbed0d815037de1dc7e1e9e80c485">tile_store</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:ae2fdbed0d815037de1dc7e1e9e80c485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the func storing data from register file to global memory enable atomic adding data into the same buffer, but support float32, float64, uint32_t, uint64_t and int type.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#ae2fdbed0d815037de1dc7e1e9e80c485">More...</a><br /></td></tr>
<tr class="separator:ae2fdbed0d815037de1dc7e1e9e80c485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352fc9c3437b2c17d830e9b31907a732"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:a352fc9c3437b2c17d830e9b31907a732"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_scatter_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a352fc9c3437b2c17d830e9b31907a732">tile_store</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:a352fc9c3437b2c17d830e9b31907a732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the func storing data from register file to shared local memory, which supports the memory surface 2d scenario.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a352fc9c3437b2c17d830e9b31907a732">More...</a><br /></td></tr>
<tr class="separator:a352fc9c3437b2c17d830e9b31907a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03d8f616221e64a76691c49e9383b91"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:af03d8f616221e64a76691c49e9383b91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_scatter_vnni_col_xe &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#af03d8f616221e64a76691c49e9383b91">tile_store</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:af03d8f616221e64a76691c49e9383b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the data store func from register file to local shared memory, where the data in register is vnni packed and col major.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#af03d8f616221e64a76691c49e9383b91">More...</a><br /></td></tr>
<tr class="separator:af03d8f616221e64a76691c49e9383b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92eed69f49cd58de734b9214937d40ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:a92eed69f49cd58de734b9214937d40ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_block_1d_xe &amp;&amp;tile_t::block_size_y !=1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a92eed69f49cd58de734b9214937d40ee">tile_store</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:a92eed69f49cd58de734b9214937d40ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the data store func from register file to shared local memory, where supports memory surface 1d or 2d scenario, and we always assume dst memory layout is row major.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#a92eed69f49cd58de734b9214937d40ee">More...</a><br /></td></tr>
<tr class="separator:a92eed69f49cd58de734b9214937d40ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7496842455743b88aeed19472ebe3ec"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </td></tr>
<tr class="memitem:ab7496842455743b88aeed19472ebe3ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_block_1d_xe &amp;&amp;tile_t::tile_size_y==1 &amp;&amp;tile_t::block_size_y==1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#ab7496842455743b88aeed19472ebe3ec">tile_store</a> (<a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;<a class="el" href="namespacegpu_1_1xetla.html#a52fa7b5d0cce636d18ddead7b3ef0072a13181d8cc01e390bf64c9e4b0d7a79f3">tile</a>, payload_t &amp;payload)</td></tr>
<tr class="memdesc:ab7496842455743b88aeed19472ebe3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the func storing data from register file to shared local memory, the data in registers will be stored to SLM in 1d mode, and we always assume dst memory layout is row major.  <a href="namespacegpu_1_1xetla_1_1subgroup.html#ab7496842455743b88aeed19472ebe3ec">More...</a><br /></td></tr>
<tr class="separator:ab7496842455743b88aeed19472ebe3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1e9e69210058a1e1b63e722d4c3a40b5"><td class="memTemplParams" colspan="2">template&lt;typename tile_desc_ , <a class="el" href="namespacegpu_1_1xetla.html#a7f225ed816e841c1d31414d872dae59d">mem_space</a> memory_space&gt; </td></tr>
<tr class="memitem:a1e9e69210058a1e1b63e722d4c3a40b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegpu_1_1xetla.html#aa8afe1d12e7777419fb6ea09534a0aa7">msg_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html#a1e9e69210058a1e1b63e722d4c3a40b5">msg_type_v</a> = <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1msg__type__query.html">msg_type_query</a>&lt;tile_desc_, memory_space&gt;::value</td></tr>
<tr class="separator:a1e9e69210058a1e1b63e722d4c3a40b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8b69b15b52946f9458d1ed844d7bd8d3" name="a8b69b15b52946f9458d1ed844d7bd8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b69b15b52946f9458d1ed844d7bd8d3">&#9670;&#160;</a></span>elemwise_cvt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T_src &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_src::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_dst::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_src::tile_desc::block_size_y==T_dst::tile_desc::block_size_y) &amp;&amp;(T_src::tile_desc::block_size_x==T_dst::tile_desc::block_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==T_dst::tile_desc::tile_size_y) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x)&gt; gpu::xetla::subgroup::elemwise_cvt </td>
          <td>(</td>
          <td class="paramtype">T_dst &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_src &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the element wise data conversion, the src and dst tile should have the same layout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>Is the destination tile data type. </td></tr>
    <tr><td class="paramname">T_src</td><td>Is the source tile data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Is the reference of the destination tile object. </td></tr>
    <tr><td class="paramname">src</td><td>Is the reference of the destination tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, in-place update in the destination tile. </dd></dl>

</div>
</div>
<a id="ac81487253528fefbbbd9ca5b394ca2c4" name="ac81487253528fefbbbd9ca5b394ca2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81487253528fefbbbd9ca5b394ca2c4">&#9670;&#160;</a></span>elemwise_cvt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T_src &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_src::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_dst::tile_desc::register_layout !=<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9a932b3cb396238423eb2f33ec17d6aa">reg_layout::linear</a>) &amp;&amp;(T_src::tile_desc::block_size_y==T_dst::tile_desc::block_size_y) &amp;&amp;(T_src::tile_desc::block_size_x==T_dst::tile_desc::block_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==T_dst::tile_desc::tile_size_y) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x)&gt; gpu::xetla::subgroup::elemwise_cvt </td>
          <td>(</td>
          <td class="paramtype">T_dst &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_src &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>element wise data conversion with scaling, the src and dst tile should have the same layout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>is the destination tile data type. </td></tr>
    <tr><td class="paramname">T_src</td><td>is the source tile data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>is the reference of the destination tile object. </td></tr>
    <tr><td class="paramname">src</td><td>is the reference of the destination tile object. </td></tr>
    <tr><td class="paramname">scale</td><td>is the scaling value to be applied before the assignment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>no return, in-place update in the destination tile. </dd></dl>

</div>
</div>
<a id="a3dc58c46491bd67b07a6e930b909a552" name="a3dc58c46491bd67b07a6e930b909a552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc58c46491bd67b07a6e930b909a552">&#9670;&#160;</a></span>elemwise_op() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> , <a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98">post_kind</a> post_op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; post_op==<a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98abc5ce62b39aff2f661146911808eadc1">post_kind::relu</a> &gt; gpu::xetla::subgroup::elemwise_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;&#160;</td>
          <td class="paramname"><em>mat_Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the element wise op for relu. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Is the tile data type. </td></tr>
    <tr><td class="paramname">post_op</td><td>Is the post processing op kind, should be relu. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_Acc</td><td>Is the reference of the tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update the data in-place. </dd></dl>

</div>
</div>
<a id="ad1c2f3de3e4f22840cb553cc3a09408c" name="ad1c2f3de3e4f22840cb553cc3a09408c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c2f3de3e4f22840cb553cc3a09408c">&#9670;&#160;</a></span>elemwise_op() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> , <a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98">post_kind</a> post_op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; post_op==<a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98ab3be9d0a0747f09c4bb18840003e3f9a">post_kind::gelu</a> &gt; gpu::xetla::subgroup::elemwise_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;&#160;</td>
          <td class="paramname"><em>mat_Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the element wise op for gelu. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Is the tile data type. </td></tr>
    <tr><td class="paramname">post_op</td><td>Is the post processing op kind, should be gelu. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_Acc</td><td>Is the reference of the tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update the data in-place. </dd></dl>

</div>
</div>
<a id="aa37e62fa495a0c8237930a4f39daece9" name="aa37e62fa495a0c8237930a4f39daece9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37e62fa495a0c8237930a4f39daece9">&#9670;&#160;</a></span>elemwise_op() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> , <a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98">post_kind</a> post_op&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; post_op==<a class="el" href="namespacegpu_1_1xetla.html#a0952e84e7d047ac828bd9daef8273f98a5c0dbba3a6ee4ac0eb26cfee75ccb8b4">post_kind::tanh</a> &gt; gpu::xetla::subgroup::elemwise_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;&#160;</td>
          <td class="paramname"><em>mat_Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the element wise op for tanh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Is the tile data type. </td></tr>
    <tr><td class="paramname">post_op</td><td>Is the post processing op kind, should be tanh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_Acc</td><td>Is the reference of the tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update the data in-place. </dd></dl>

</div>
</div>
<a id="af6a12cfd0a2d3621b16109bfe772558d" name="af6a12cfd0a2d3621b16109bfe772558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a12cfd0a2d3621b16109bfe772558d">&#9670;&#160;</a></span>row_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T_src &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_dst::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_src::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==1)&gt; gpu::xetla::subgroup::row_broadcast </td>
          <td>(</td>
          <td class="paramtype">T_dst &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_src &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts 1d src tile to the entire 2d tile, as well as do the data conversion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>Is the destination tile data type. </td></tr>
    <tr><td class="paramname">T_src</td><td>Is the source tile data type, interpreted as 1D data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Is the reference of the destination tile object. </td></tr>
    <tr><td class="paramname">src</td><td>Is the reference of the destination tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, in-place update in the destination tile. </dd></dl>

</div>
</div>
<a id="ad458951cf3988199a5217f2e6017a486" name="ad458951cf3988199a5217f2e6017a486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad458951cf3988199a5217f2e6017a486">&#9670;&#160;</a></span>tile_broadcast_op()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename op , typename matAcc_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::xetla::subgroup::tile_broadcast_op </td>
          <td>(</td>
          <td class="paramtype">matAcc_t &amp;&#160;</td>
          <td class="paramname"><em>matAcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__xetla__core__base__types.html#ga8cf5d016d24c8870706e20c376287e04">xetla_vector</a>&lt; typename matAcc_t::dtype, matAcc_t::tile_size_y &gt;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae110043dd5332ce2a7ef91d2c8ae79ef" name="ae110043dd5332ce2a7ef91d2c8ae79ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae110043dd5332ce2a7ef91d2c8ae79ef">&#9670;&#160;</a></span>tile_load() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_2d_xe &gt; gpu::xetla::subgroup::tile_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads data from 2D memory surface. </p>
<p >Loads an array of rectangular regions (X,Y)..(X+W,Y+H) from memory into registers. Each block will be loaded serially by its corresponding payload. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers. These registers will be the destination of load operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory information Payload indicates the source of load operation. </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, holds the return data of the loads. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for loads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update in place. </dd></dl>

</div>
</div>
<a id="af981410d657174c1d3d7e9e0ce45a9c8" name="af981410d657174c1d3d7e9e0ce45a9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af981410d657174c1d3d7e9e0ce45a9c8">&#9670;&#160;</a></span>tile_load() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_block_1d_xe &gt; gpu::xetla::subgroup::tile_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function loads data from memory. </p>
<p >For each enabled SIMT lane, a vector is read from memory into registers. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers. These registers will be the destination of load operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory information. Payload indicates the source of load operation. </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, holds the return data of the loads. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for loads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update in place. </dd></dl>

</div>
</div>
<a id="a12e7576711f868349f625b3aa92db238" name="a12e7576711f868349f625b3aa92db238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7576711f868349f625b3aa92db238">&#9670;&#160;</a></span>tile_load() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_scatter_xe &gt; gpu::xetla::subgroup::tile_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the data load func from local shared memory to register file, which supports the memory surface is 1d or 2d scenario. </p>
<p >And we always assume data in SLM is row major. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the destination of load operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory information. Payload indicates the source of load operation. </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, holds the return data of the loads. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for loads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update in place. </dd></dl>

</div>
</div>
<a id="a79cb1cc8488ef2bed589c9719b8b5713" name="a79cb1cc8488ef2bed589c9719b8b5713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cb1cc8488ef2bed589c9719b8b5713">&#9670;&#160;</a></span>tile_load() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__load__type.html">detail::check_load_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_block_1d_xe &gt; gpu::xetla::subgroup::tile_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the data load func from shared local memory to register file, which supports the memory surface is 1d scenario. </p>
<p >And the src memory layout is always row major. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers. These registers will be the destination of load operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory information. Payload indicates the source of load operation. </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, holds the return data of the loads. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for loads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update in place. </dd></dl>

</div>
</div>
<a id="aaceb202d8614f8ac1526c8d6d81871af" name="aaceb202d8614f8ac1526c8d6d81871af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb202d8614f8ac1526c8d6d81871af">&#9670;&#160;</a></span>tile_prefetch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__prefetch__type.html">detail::check_prefetch_type</a>&lt; payload_t &gt;::is_global_2d_xe &gt; gpu::xetla::subgroup::tile_prefetch </td>
          <td>(</td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is prefetch data func, which data located in global memory is prefetched to cache, where has higher bandwidth. </p>
<p >e.g. In gemm, prefetch next iteration data for mma consumption. This func is specicalized for block 2d scenario. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct illustrating memory info payload indicates the source of prefetch operation. </td></tr>
    <tr><td class="paramname">L1</td><td>Is cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for prefetches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a5f23fa860546dda8f99f578d614198" name="a4a5f23fa860546dda8f99f578d614198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f23fa860546dda8f99f578d614198">&#9670;&#160;</a></span>tile_prefetch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__prefetch__type.html">detail::check_prefetch_type</a>&lt; payload_t &gt;::is_global_block_1d_xe &gt; gpu::xetla::subgroup::tile_prefetch </td>
          <td>(</td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is prefetch data func, which data located in global memory is prefetched to cache, where has higher bandwidth. </p>
<p >e.g. In gemm, prefetch next iteration data for mma consumption. This func is specicalized for block 1d scenario. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct illustrating memory info payload indicates the source of prefetch operation </td></tr>
    <tr><td class="paramname">L1</td><td>Is cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for prefetches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae231c0f2ba538dd630ff96861a796544" name="ae231c0f2ba538dd630ff96861a796544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae231c0f2ba538dd630ff96861a796544">&#9670;&#160;</a></span>tile_prefetch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::cached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::cached, typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__prefetch__type.html">detail::check_prefetch_type</a>&lt; payload_t &gt;::is_local_xe &gt; gpu::xetla::subgroup::tile_prefetch </td>
          <td>(</td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is prefetch data func. </p>
<p >Current shared local memory prefetch is not supported yet. Only used to keep the consistency with global prefetch. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct illustrating memory info. </td></tr>
    <tr><td class="paramname">L1</td><td>Is cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for prefetches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c36bfacc34c29c899bcbc53473148ac" name="a1c36bfacc34c29c899bcbc53473148ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c36bfacc34c29c899bcbc53473148ac">&#9670;&#160;</a></span>tile_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a7bbd70f1164d3a7251729e89fffc0609">reduce_op</a> reduce_kind, typename mat_t , typename dtype_acc , int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(dim==1), <a class="el" href="group__xetla__core__base__types.html#ga8cf5d016d24c8870706e20c376287e04">xetla_vector</a>&lt; typename mat_t::dtype, mat_t::tile_desc::tile_size_y &gt; &gt; gpu::xetla::subgroup::tile_reduce </td>
          <td>(</td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The idea is 1) allocate a temp buffer; 2) accumulate the entire tile into temp buffer; 3) reduce within temp buffer</p>

</div>
</div>
<a id="abb3737ab94d26bfe109fa71cfc8ca92c" name="abb3737ab94d26bfe109fa71cfc8ca92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3737ab94d26bfe109fa71cfc8ca92c">&#9670;&#160;</a></span>tile_row_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T_src , bool accumulate = true, typename dtype_acc  = float, uint32_t num_acc = 4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_dst::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_src::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa78506882d645395a052df8b01a927395">reg_layout::tiled</a>) &amp;&amp;(T_dst::tile_desc::tile_size_x==T_src::tile_desc::tile_size_x) &amp;&amp;(T_dst::tile_desc::tile_size_y==1)&gt; gpu::xetla::subgroup::tile_row_reduce </td>
          <td>(</td>
          <td class="paramtype">T_dst &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_src &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduce 2d src tile to the 1d tile, and output to 1d dst. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>Is the destination tile data type, interpreted as 1d data. </td></tr>
    <tr><td class="paramname">T_src</td><td>Is the source tile data type, interpreted as 2d data. </td></tr>
    <tr><td class="paramname">accumulate</td><td>is to accumulate the old value or not. </td></tr>
    <tr><td class="paramname">dtype_acc</td><td>Is the accumulation data type, src ==&gt; convert to dtype_acc ==&gt; reduction + accumulation ==&gt; convert to dtype_dst. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Is the reference of the destination tile object. </td></tr>
    <tr><td class="paramname">src</td><td>Is the reference of the destination tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, in-place update in the destination tile. </dd></dl>
<p >Here we rely on compiler to generate mixed mode for <a class="el" href="structgpu_1_1xetla_1_1bf16.html" title="xetla bf16 data type.">bf16</a></p>
<p >The idea is 1) allocate a temp buffer; 2) accumulate the entire tile into temp buffer; 3) reduce within temp buffer This will introduce additional instructions to initialize the temp buffer, but will have more parallelism</p>

</div>
</div>
<a id="aca86d85d16cd70ce167a4819af5d29ef" name="aca86d85d16cd70ce167a4819af5d29ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca86d85d16cd70ce167a4819af5d29ef">&#9670;&#160;</a></span>tile_store() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_2d_xe &gt; gpu::xetla::subgroup::tile_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the func storing data from register file to global memory. </p>
<p >store a rectangular region (X,Y)..(X+W,Y+H) into memory from registers. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the source of store operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory info payload indicates the destination of store operation. </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, contains the data to be stored. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for stores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a343abc18e254f69fa1f67cbef11d187b" name="a343abc18e254f69fa1f67cbef11d187b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343abc18e254f69fa1f67cbef11d187b">&#9670;&#160;</a></span>tile_store() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_block_1d_xe &gt; gpu::xetla::subgroup::tile_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the func storing data from register file to global memory. </p>
<p >For each enabled SIMT lane, a vector is written into memory from registers. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the source of store operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory info payload indicates the destination of store operation </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, contains the data to be stored. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for stores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2fdbed0d815037de1dc7e1e9e80c485" name="ae2fdbed0d815037de1dc7e1e9e80c485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fdbed0d815037de1dc7e1e9e80c485">&#9670;&#160;</a></span>tile_store() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::uncached, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_global_atomic_xe &gt; gpu::xetla::subgroup::tile_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the func storing data from register file to global memory enable atomic adding data into the same buffer, but support float32, float64, uint32_t, uint64_t and int type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the source of store operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory info payload indicates the destination of store operation </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, contains the data to be stored. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for stores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a352fc9c3437b2c17d830e9b31907a732" name="a352fc9c3437b2c17d830e9b31907a732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352fc9c3437b2c17d830e9b31907a732">&#9670;&#160;</a></span>tile_store() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_scatter_xe &gt; gpu::xetla::subgroup::tile_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the func storing data from register file to shared local memory, which supports the memory surface 2d scenario. </p>
<p >And the dst memory layout is is always row major. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the source of store operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory info payload indicates the destination of store operation </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, contains the data to be stored. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for stores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af03d8f616221e64a76691c49e9383b91" name="af03d8f616221e64a76691c49e9383b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03d8f616221e64a76691c49e9383b91">&#9670;&#160;</a></span>tile_store() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_scatter_vnni_col_xe &gt; gpu::xetla::subgroup::tile_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the data store func from register file to local shared memory, where the data in register is vnni packed and col major. </p>
<p >And we always assume the dst memory layout is row major. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the source of store operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory info payload indicates the destination of store operation </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, contains the data to be stored. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for stores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92eed69f49cd58de734b9214937d40ee" name="a92eed69f49cd58de734b9214937d40ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eed69f49cd58de734b9214937d40ee">&#9670;&#160;</a></span>tile_store() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_block_1d_xe &amp;&amp;tile_t::block_size_y !=1 &gt; gpu::xetla::subgroup::tile_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the data store func from register file to shared local memory, where supports memory surface 1d or 2d scenario, and we always assume dst memory layout is row major. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the source of store operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory info payload indicates the destination of store operation </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, contains the data to be stored. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for stores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7496842455743b88aeed19472ebe3ec" name="ab7496842455743b88aeed19472ebe3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7496842455743b88aeed19472ebe3ec">&#9670;&#160;</a></span>tile_store() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L1 = cache_hint::write_back, <a class="el" href="namespacegpu_1_1xetla.html#a23ee6c8b836eb63360633951d75d7e30">cache_hint</a> L3 = cache_hint::write_back, typename <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> , typename payload_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1detail_1_1check__store__type.html">detail::check_store_type</a>&lt; <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a>, payload_t &gt;::is_local_block_1d_xe &amp;&amp;tile_t::tile_size_y==1 &amp;&amp;tile_t::block_size_y==1 &gt; gpu::xetla::subgroup::tile_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html">tile_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">payload_t &amp;&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the func storing data from register file to shared local memory, the data in registers will be stored to SLM in 1d mode, and we always assume dst memory layout is row major. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a></td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a> struct contains registers These registers will be the source of store operation. </td></tr>
    <tr><td class="paramname">payload_t</td><td>Is the <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1mem__payload__t.html" title="Is to illustrate the memory information.">mem_payload_t</a> struct describing the memory info payload indicates the destination of store operation </td></tr>
    <tr><td class="paramname">L1</td><td>Is the cache hint for L1 cache. </td></tr>
    <tr><td class="paramname">L3</td><td>Is the cache hint for L3 cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>Is the tile object with type <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1tile__t.html" title="Is a struct contains some register file.">tile_t</a>, contains the data to be stored. </td></tr>
    <tr><td class="paramname">payload</td><td>Is the payload object with type payload_t. Contains all the information for stores. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81b12c34ad3ef3de43d0b01c4e5e1134" name="a81b12c34ad3ef3de43d0b01c4e5e1134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b12c34ad3ef3de43d0b01c4e5e1134">&#9670;&#160;</a></span>vnni_reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt; T::tile_desc::register_layout==<a class="el" href="namespacegpu_1_1xetla.html#a51137fd81d0d9d2156525a1e279432aaa9c072496656f07aeb105a1bc09a218b5">reg_layout::vnni_tiled</a> &gt; gpu::xetla::subgroup::vnni_reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="multi__head__attention_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a> &amp;&#160;</td>
          <td class="paramname"><em>mat_Acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts vnni_tiled layout format to tiled layout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Is the tile data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_Acc</td><td>Is the reference of the tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, update the data in-place. </dd></dl>

</div>
</div>
<a id="a62f0095d099fd6925beaf78858106ba7" name="a62f0095d099fd6925beaf78858106ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f0095d099fd6925beaf78858106ba7">&#9670;&#160;</a></span>vnni_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_dst , typename T_src &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="common_2core_2common_8hpp.html#a9ed53999886ec13b86a4fe2e0fc16765">__XETLA_API</a> std::enable_if_t&lt;(T_src::tile_desc::block_size_y==T_dst::tile_desc::block_size_y) &amp;&amp;(T_src::tile_desc::block_size_x==T_dst::tile_desc::block_size_x) &amp;&amp;(T_src::tile_desc::tile_size_y==T_dst::tile_desc::tile_size_y) &amp;&amp;(T_src::tile_desc::tile_size_x==T_dst::tile_desc::tile_size_x)&gt; gpu::xetla::subgroup::vnni_transform </td>
          <td>(</td>
          <td class="paramtype">T_dst &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_src &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes vnni layout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_dst</td><td>Is the destination tile data type. </td></tr>
    <tr><td class="paramname">T_src</td><td>Is the source tile data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Is the reference of the destination tile object. </td></tr>
    <tr><td class="paramname">src</td><td>Is the reference of the destination tile object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return, in-place update in the destination tile. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1e9e69210058a1e1b63e722d4c3a40b5" name="a1e9e69210058a1e1b63e722d4c3a40b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9e69210058a1e1b63e722d4c3a40b5">&#9670;&#160;</a></span>msg_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tile_desc_ , <a class="el" href="namespacegpu_1_1xetla.html#a7f225ed816e841c1d31414d872dae59d">mem_space</a> memory_space&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegpu_1_1xetla.html#aa8afe1d12e7777419fb6ea09534a0aa7">msg_type</a> gpu::xetla::subgroup::msg_type_v = <a class="el" href="structgpu_1_1xetla_1_1subgroup_1_1msg__type__query.html">msg_type_query</a>&lt;tile_desc_, memory_space&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegpu.html">gpu</a></li><li class="navelem"><a class="el" href="namespacegpu_1_1xetla.html">xetla</a></li><li class="navelem"><a class="el" href="namespacegpu_1_1xetla_1_1subgroup.html">subgroup</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
